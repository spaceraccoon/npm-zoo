// Generated by CoffeeScript 1.12.7
(function() {
  var COLLECTIONS_TOPIC, EventEmitter2, MAIN_TOPIC, MqttDecorator, QOS, currentClientId, currentSocketId, debug, fs, mqtt;

  EventEmitter2 = require('eventemitter2').EventEmitter2;

  mqtt = require('mqtt');

  MqttDecorator = require('./MqttDecorator');

  fs = require('fs');

  debug = require('debug')("device-mqtt:main");

  currentClientId = 0;

  currentSocketId = 0;

  MAIN_TOPIC = 'commands';

  COLLECTIONS_TOPIC = 'collections';

  QOS = 2;

  module.exports = function(arg) {
    var ACTIONS_TOPIC, GLOBAL_OBJECT_DB_TOPIC, OBJECT_DB_TOPIC, SINGLE_ITEM_DB_TOPIC, SINGLE_ITEM_GLOBAL_DB_TOPIC, _client, _createClient, _createSocket, _init, _initApis, _loadTlsFiles, _messageHandler, _mqtt, _socket, _startListeningToMessages, _subFirstTime, _subToDbTopics, api_commands, api_db, clientId, connect, customPublish, customSubscribe, destroy, extraOpts, host, port, ref, ref1, tls;
    host = arg.host, port = arg.port, clientId = arg.clientId, tls = (ref = arg.tls) != null ? ref : {}, extraOpts = (ref1 = arg.extraOpts) != null ? ref1 : {};
    ACTIONS_TOPIC = MAIN_TOPIC + "/" + clientId + "/+";
    SINGLE_ITEM_DB_TOPIC = clientId + "/collections/+";
    OBJECT_DB_TOPIC = clientId + "/collections/+/+";
    GLOBAL_OBJECT_DB_TOPIC = "global/collections/+";
    SINGLE_ITEM_GLOBAL_DB_TOPIC = "global/collections/+/+";
    if (!clientId) {
      throw new Error('clientId must be provided');
    }
    if (-1 !== clientId.indexOf('/')) {
      throw new Error('clientId must not include a `/`');
    }
    api_commands = null;
    api_db = null;
    _client = new EventEmitter2;
    _client.connected = false;
    _client.id = ++currentClientId;
    _socket = new EventEmitter2({
      wildcard: true,
      delimiter: '/'
    });
    _socket.id = ++currentSocketId;
    _mqtt = null;
    connect = function(will) {
      var _mqttUrl, connectionOptions;
      connectionOptions = {};
      _mqttUrl = "mqtt://" + host + ":" + port;
      if (Object.keys(tls).length) {
        connectionOptions = Object.assign({}, connectionOptions, _loadTlsFiles(tls));
        _mqttUrl = "mqtts://" + host + ":" + port;
      }
      if (Object.keys(extraOpts).length) {
        connectionOptions = Object.assign({}, connectionOptions, extraOpts);
      }
      if (will) {
        will = Object.assign({}, will, {
          qos: 2,
          retain: true
        });
        connectionOptions = Object.assign({}, connectionOptions, {
          clientId: clientId,
          clean: false,
          will: will
        });
      } else {
        connectionOptions = Object.assign({}, connectionOptions, {
          clientId: clientId,
          clean: false
        });
      }
      debug("Connecting to MQTT with url " + _mqttUrl + " and options", connectionOptions);
      _mqtt = mqtt.connect(_mqttUrl, connectionOptions);
      _mqtt = MqttDecorator(_mqtt);
      _init(_mqtt);
      return _initApis(_mqtt);
    };
    destroy = function(cb) {
      debug("[MQTT client] Ending");
      return _mqtt.end(function(error) {
        debug("[MQTT client] Ended");
        return typeof cb === "function" ? cb(error) : void 0;
      });
    };
    customPublish = function(arg1, cb) {
      var message, opts, topic;
      topic = arg1.topic, message = arg1.message, opts = arg1.opts;
      return _mqtt.publish(topic, message, opts, cb);
    };
    customSubscribe = function(arg1, cb) {
      var opts, topic;
      topic = arg1.topic, opts = arg1.opts;
      return _mqtt.subscribe(topic, opts, cb);
    };
    _loadTlsFiles = function(arg1) {
      var ca, cert, key;
      key = arg1.key, ca = arg1.ca, cert = arg1.cert;
      return {
        key: fs.readFileSync(key),
        ca: [fs.readFileSync(ca)],
        cert: fs.readFileSync(cert)
      };
    };
    _initApis = function(_mqtt) {
      api_commands = (require('./api_commands'))({
        mqttInstance: _mqtt,
        socket: _socket,
        socketId: clientId
      });
      return api_db = (require('./api_db'))({
        mqttInstance: _mqtt,
        socket: _socket,
        socketId: clientId
      });
    };
    _subFirstTime = function(cb) {
      var topics;
      _startListeningToMessages();
      topics = [ACTIONS_TOPIC, SINGLE_ITEM_DB_TOPIC, OBJECT_DB_TOPIC, GLOBAL_OBJECT_DB_TOPIC, SINGLE_ITEM_GLOBAL_DB_TOPIC];
      debug("Subscribing to topics for first time: " + topics);
      return _mqtt.sub(topics, {
        qos: QOS
      }, function(error, granted) {
        var errorMsg;
        if (error) {
          errorMsg = "Error subscribing to actions topic. Reason: " + error.message;
          return cb(new Error(errorMsg));
        }
        debug("Subscribed correctly to topics " + topics);
        return cb();
      });
    };
    _subToDbTopics = function(cb) {
      var topics;
      topics = [SINGLE_ITEM_DB_TOPIC, OBJECT_DB_TOPIC, GLOBAL_OBJECT_DB_TOPIC, SINGLE_ITEM_GLOBAL_DB_TOPIC];
      debug("Subscribing to db topics: " + topics);
      return _mqtt.sub(topics, {
        qos: QOS
      }, function(error, granted) {
        var errorMsg;
        if (error) {
          errorMsg = "Error subscribing to actions topic. Reason: " + error.message;
          return cb(new Error(errorMsg));
        }
        debug("Subscribed correctly to topics " + topics);
        return cb();
      });
    };
    _startListeningToMessages = function() {
      debug("Setting messageHandler");
      return _mqtt.on('message', _messageHandler);
    };
    _messageHandler = function(topic, message) {
      var actionRegex, dbRegex, globalRegex, responseRegex;
      responseRegex = api_commands.responseRegex, actionRegex = api_commands.actionRegex;
      dbRegex = api_db.dbRegex, globalRegex = api_db.globalRegex;
      topic = topic.toString();
      message = message.toString();
      if (responseRegex.test(topic)) {
        debug("Received response message: " + topic);
        return api_commands.handleMessage(topic, message, 'result');
      } else if (actionRegex.test(topic)) {
        debug("Received action message: " + topic);
        return api_commands.handleMessage(topic, message, 'action');
      } else if (dbRegex.test(topic)) {
        debug("Received db message: " + topic);
        return api_db.handleMessage(topic, message, 'local');
      } else if (globalRegex.test(topic)) {
        debug("Received global message: " + topic);
        return api_db.handleMessage(topic, message, 'global');
      } else {
        debug("Received other message: " + topic);
        return _socket.emit(topic, message);
      }
    };
    _createSocket = function() {
      var createCollection, createGlobalCollection, send;
      debug("Create socket", _socket.id);
      send = api_commands.send;
      createCollection = api_db.createCollection, createGlobalCollection = api_db.createGlobalCollection;
      _socket.send = send;
      _socket.createCollection = createCollection;
      _socket.createGlobalCollection = createGlobalCollection;
      _socket.customPublish = customPublish;
      _socket.customSubscribe = customSubscribe;
      return _socket;
    };
    _init = function(mqttInstance) {
      var _onClose, _onConnection, _onError, _onReconnect;
      _onConnection = function(connack) {
        _client.connected = true;

        /*
        				The connack.sessionPresent is set to `true` if
        				the client has already a persistent session.
        				If the session is there, there is no need to
        				sub again to the topics.
         */
        return _subFirstTime(function(error) {
          if (error) {
            _client.emit('error', error);
          }
          return _client.emit('connected', _createSocket());
        });
      };
      _onReconnect = function() {
        debug("[MQTT client] reconnect");
        return _client.emit('reconnecting');
      };
      _onClose = function() {
        debug("[MQTT client] close");
        _client.emit('disconnected');
        _socket.emit('disconnected');
        debug("Removing message handler");
        _mqtt.removeListener('message', _messageHandler);
        return _client.connected = false;
      };
      _onError = function(error) {
        debug("[MQTT client] error: " + error.message);
        return _client.emit('error', error);
      };
      mqttInstance.on('error', _onError);
      mqttInstance.on('connect', _onConnection);
      mqttInstance.on('reconnect', _onReconnect);
      return mqttInstance.on('close', _onClose);
    };
    _createClient = function() {
      _client.connect = connect;
      _client.destroy = destroy;
      return _client;
    };
    return _createClient();
  };

}).call(this);
